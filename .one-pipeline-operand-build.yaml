version: '1'

setup:
  image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12
  script: |
    #!/usr/bin/env bash

    GHE_TOKEN=$(cat "$WORKSPACE/git-token")
    GHE_TOKEN=$(get_env git-token)
    
    SKIP_SETUP=$(get_env SKIP_SETUP)

    if [[ "$SKIP_SETUP" != 1 ]]; then
      GH_TOKEN=$(get_env git-token-GH)
      OWNER=$(jq -r '.services[] | select(.toolchain_binding.name=="app-repo") | .parameters.owner_id' /toolchain/toolchain.json)
      REPO=$(jq -r '.services[] | select(.toolchain_binding.name=="app-repo") | .parameters.repo_name' /toolchain/toolchain.json)
      REPO=${REPO%.git}
      REPO=sample-getting-started
      BRANCH=$(get_env branch)
      # The 'owner' is really the org, not the user with admin access to repo
      OWNER=mcurran-us
      echo "Owner: $OWNER"
      echo "REPO: $REPO"
      echo "BRANCH: $BRANCH"

      curl -u :$GH_TOKEN https://api.github.com/repos/$OWNER/$REPO/branches/$BRANCH/protection -H "Accept: application/vnd.github.v3+json" -X PUT -d '{"required_pull_request_reviews":{"dismiss_stale_reviews":true,"required_approving_review_count":1},"enforce_admins":null,"restrictions":null,"required_status_checks":null}'
    fi  

    # clone the cpp-pipelines repo where custom scripts are maintained
    GHE_BRANCH=$(get_env cpp-pipelines-branch "master")
    git clone --depth 1 --branch $GHE_BRANCH https://${GHE_TOKEN}@github.ibm.com/CICD-CPP/cpp-pipelines "${WORKSPACE}"/cpp-pipeline-scripts
    CUSTOM_SCRIPTS_PATH="${WORKSPACE}/cpp-pipeline-scripts"  
    set_env custom-scripts-path "${CUSTOM_SCRIPTS_PATH}"
    
test:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    SKIP_UNIT_TESTS=$(get_env SKIP_UNIT_TESTS)
    if [[ "$SKIP_UNIT_TESTS" != 1 ]]; then
      cd ../"$(load_repo app-repo path)"
      mvn clean package liberty:create liberty:install-feature liberty:test-start liberty:deploy failsafe:integration-test failsafe:verify liberty:test-stop
    fi

static-scan:
  dind: true
  image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12
  script: |
    #!/usr/bin/env bash          
    SKIP_STATIC_SCAN=$(get_env SKIP_STATIC_SCAN)
    if [[ "$SKIP_STATIC_SCAN" != 1 ]]; then
       read -r SONAR_HOST_URL <<< "$(get_env sonarqube | jq -r '.parameters.dashboard_url' | sed 's:/*$::')"
       read -r SONAR_USER <<< "$(get_env sonarqube | jq -r '.parameters.user_login')"
       SONARQUBE_INSTANCE_ID=$(get_env sonarqube | jq -r '.instance_id')
       read -r SONAR_PASS <<< "$(jq -r --arg sonar_instance "$SONARQUBE_INSTANCE_ID" '[.services[] | select(."service_id"=="sonarqube")][] | select(."instance_id"==$sonar_instance) | .parameters.user_password' /toolchain/toolchain.json)"
       touch "$WORKSPACE"/liberty-getting-started/sonar-project.properties
       cat << EOF > "$WORKSPACE"/liberty-getting-started/sonar-project.properties
       sonar.projectKey=liberty-getting-started
       sonar.host.url=$SONAR_HOST_URL
       sonar.sources=.
       sonar.login=$SONAR_USER
       sonar.password=$SONAR_PASS
       sonar.c.file.suffixes=-
       sonar.cpp.file.suffixes=-
       sonar.objc.file.suffixes=-
    EOF
       chmod -x "$WORKSPACE"/liberty-getting-started/sonar-project.properties
       "${ONE_PIPELINE_PATH}"/internal/sonarqube/sonarqube_run
    fi


compliance-checks:
  image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12
  image_pull_policy: IfNotPresent
  abort_on_failure: false
  dind: true 
  script: |
    #!/usr/bin/env bash
    
    # mend should run as part of compliance-checks now 
    # environment property: opt-in-mend
    echo "---- executing compliance-checks/run.sh ----"
    "${COMMONS_PATH}"/compliance-checks/run.sh


containerize:
  dind: true
  image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.12@sha256:ff4053b0bca784d6d105fee1d008cfb20db206011453071e86b69ca3fde706a4
  script: |
    #!/usr/bin/env bash
    set -eo pipefail
    
    #
    # Install your build dependencies here for the whitesource unified agent dependency scan
    #
    if [[ "$PIPELINE_DEBUG" == 1 ]]; then
      trap env EXIT
      env
      set -x
    fi
    
    # Build images
    PIPELINE_USERNAME=$(get_env ibmcloud-api-user)
    PIPELINE_PASSWORD=$(get_env ibmcloud-api-key-staging)  
    CONTAINER_REGISTRY=$(get_env CONTAINER_REGISTRY)
    REGISTRY_REPO=$(get_env REGISTRY_REPO "cp/wshe/open-liberty/samples/getting-started")
    IMAGE_TAG=$(get_env IMAGE_TAG)
    IMAGE=$CONTAINER_REGISTRY/$REGISTRY_REPO:$IMAGE_TAG
    cd ../"$(load_repo app-repo path)"
    mvn package
    
    docker pull icr.io/appcafe/open-liberty:kernel-slim-java11-openj9-ubi
    docker build -t $IMAGE .
    
    # Push image to staging
    echo $PIPELINE_PASSWORD | docker login stg.icr.io -u "$PIPELINE_USERNAME" --password-stdin
    docker push $IMAGE       
    # Save artifacts
    DIGEST="$(docker inspect --format='{{index .RepoDigests 0}}' "${IMAGE}" | awk -F@ '{print $2}')"
    ARCH="amd64"
    echo "Saving artifact $IMAGE_TAG name=$IMAGE digest=$DIGEST arch=$ARCH"
    save_artifact $IMAGE_TAG type=image name="$IMAGE" "digest=$DIGEST" "arch=$ARCH" 
    

sign-artifact:
 image: wcp-compliance-automation-team-docker-local.artifactory.swg-devops.com/csso-image-sign:1.0.0@sha256:cb22e6ad6b3469155719f6bf09bde641208a1e349e5ccc09407204bb069f7b4e
 script: |
    #!/usr/bin/env bash
    echo "Skipping code signing..."

    # Environment variables:
    # ciso-ibmcloud-api-key - source registry key 
    # ciso-destination-registry 
    # ciso-destination-apikey
    # ciso-destination-namespace
    # registry-namespace - source registry namespace

    #"${COMMONS_PATH}"/ciso/sign_icr.sh


acceptance-test:
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12
  script: |
    #!/usr/bin/env bash
    
    if [[ "$PIPELINE_DEBUG" == 1 ]]; then
      trap env EXIT
      env
      set -x
    fi
    
    PIPELINE_USERNAME=$(get_env ibmcloud-api-user)
    PIPELINE_PASSWORD=$(get_env ibmcloud-api-key-staging)  
    CONTAINER_REGISTRY=$(get_env CONTAINER_REGISTRY "stg.icr.io")
    REGISTRY_REPO=$(get_env REGISTRY_REPO "cp/wshe/open-liberty/samples/getting-started")
    IMAGE_TAG=$(get_env IMAGE_TAG)
    IMAGE=$CONTAINER_REGISTRY/$REGISTRY_REPO:$IMAGE_TAG
    
    echo $PIPELINE_PASSWORD | docker login stg.icr.io -u "$PIPELINE_USERNAME" --password-stdin
    docker pull $IMAGE
    docker images
    
    docker run -d --name getting-started-sample -p 9080:9080 $IMAGE
    docker ps
    
    # Wait for starter planet
    maxWait=30
    count=0
    while [ "$count" != "$maxWait" ] && ! docker logs getting-started-sample | grep -q "CWWKF0011I";
    do
        count=$(( $count + 1 ))
        echo "Waiting for CWWKF0011I (Smarter Planet msg) in log. $count / $maxWait seconds."
        sleep 1
    done
    if [[ "$count" == "$maxWait" ]]; then
      echo "Did not find CWWKF0011I (Smarter Planet msg) in log within $maxWait seconds."
      exit 1;
    fi
    # Test the endpoints for 200 response code
    curl -f -s -I "0.0.0.0:9080" &>/dev/null && echo "OK: Landing page did return 200" || { echo 'FAIL: Sample App landing page did not return 200' ; exit 1; }
    curl -f -s "0.0.0.0:9080" | grep -q '<title>Open Liberty - Getting Started Sample</title>' && echo "OK: Sample App landing page contained '<title>Open Liberty - Getting Started Sample</title>'" || { echo 'FAIL: Did not find "<title>Open Liberty - Getting Started Sample</title>" in response' ; exit 1; }
    curl -f -s -I "0.0.0.0:9080/system/properties" &>/dev/null && echo "OK: /system/properties did return 200" || { echo 'FAIL: /system/properties did not return 200' ; exit 1; }
    curl -f -s -I "0.0.0.0:9080/system/config" &>/dev/null && echo "OK: /system/config did return 200" || { echo 'FAIL: /system/config did not return 200' ; exit 1; }
    curl -f -s -I "0.0.0.0:9080/system/runtime" &>/dev/null && echo "OK: /system/runtime did return 200" || { echo 'FAIL: /system/runtime did not return 200' ; exit 1; }
    curl -f -s -I "0.0.0.0:9080/health" &>/dev/null && echo "OK: /health did return 200" || { echo 'FAIL: /health did not return 200' ; exit 1; }
    curl -f -s "0.0.0.0:9080/metrics" &>/dev/null && echo "OK: /metrics did return 200" || { echo 'FAIL: /metrics did not return 200' ; exit 1; }    



scan-artifact:
  dind: true
  abort_on_failure: false
  image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12  
  script: |
    #!/usr/bin/env bash
    source "${ONE_PIPELINE_PATH}/internal/tools/logging"

    if [ -n "$(get_env multiscan-execute-remote "")" ]; then

      IMAGES_TO_SCAN=""
      for ARTIFACT_IMAGE in $(list_artifacts); do
        IMAGE=$(load_artifact $ARTIFACT_IMAGE name 2>/dev/null)
        if [[ -z "${IMAGE}" ]]; then 
          continue
        else
          IMAGES_TO_SCAN+="${IMAGE}\n"
        fi  
      done

      banner "=== IMAGES_TO_SCAN ==="
      debug "$IMAGES_TO_SCAN"  

      #
      # invoke the security scanning toolchain 
      #

      SCAN_APIKEY=$(get_env scan-ibmcloud-api-key)
      SCANNING_PIPELINE_ID=$(get_env security-scanning-pipeline-id)
      TRIGGER_NAME=$(get_env security-scanning-pipeline-trigger)
      TRIGGER_PROPERTIES_JSON="{\"images-to-scan\": \"$(echo ${IMAGES_TO_SCAN})\"}"    
  
      ibmcloud update -f
      ibmcloud login --apikey "$SCAN_APIKEY" -r "us-south" -a "https://cloud.ibm.com"    

      RUN_DATA=$(ibmcloud dev tekton-trigger "$SCANNING_PIPELINE_ID" --trigger-name "$TRIGGER_NAME" --trigger-properties "$TRIGGER_PROPERTIES_JSON" --output json)
      RUN_ID=$(echo $RUN_DATA | jq -r '.id')
      echo "Security Scanning Pipeline Run ID=$RUN_ID"
      MAX_TRIES=600
      COMPLETE=0
      for (( TRIES=0; TRIES<=$MAX_TRIES; TRIES++ ))
      do
        RESULT=$(ibmcloud dev tekton-pipelinerun $SCANNING_PIPELINE_ID --run-id ${RUN_ID} --output json | jq -r '.status.state')
        if [[ $RESULT != "passed" && $RESULT != "failed" && $RESULT != "cancelled" && $RESULT != "succeeded" ]];then
            sleep 10
        else
            COMPLETE=1
            break
        fi
      done
      echo "Security Scanning Pipeline returned $RESULT"     
      echo "Security Scanning Pipeline URL: https://cloud.ibm.com/devops/pipelines/tekton/${SCANNING_PIPELINE_ID}/runs/${RUN_ID}/build-scan-artifact/run-stage?env_id=ibm:yp:us-south"

    else
      # Call cpp-pipelines customized image scanning script, which will invoke the image multiscan script 
      CUSTOM_SCRIPTS_PATH=$(get_env custom-scripts-path "${ONE_PIPELINE_PATH}")
      source "${CUSTOM_SCRIPTS_PATH}"/scripts/script_functions.sh
      runScript "${CUSTOM_SCRIPTS_PATH}" scan-artifact/scan.sh
    fi

release:
    abort_on_failure: false
    image: icr.io/continuous-delivery/pipeline/pipeline-base-ubi:3.12
    script: |
      #!/usr/bin/env bash
      echo "Release running"
